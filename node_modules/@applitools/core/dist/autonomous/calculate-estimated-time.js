"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCalculateEstimatedTime = void 0;
const calculate_required_sizes_1 = require("../automation/utils/calculate-required-sizes");
const defaults_1 = require("../automation/utils/defaults");
const verify_environment_info_1 = require("../ufg/utils/verify-environment-info");
const populate_eyes_server_settings_1 = require("../utils/populate-eyes-server-settings");
function makeCalculateEstimatedTime({ core, logger, }) {
    return async function calculateEstimatedTime({ settings }) {
        var _a;
        (0, populate_eyes_server_settings_1.populateEyesServerSettings)(settings);
        const accountInfo = await core.getAccountInfo({ settings, logger });
        const ufgClient = await core.getUFGClient({
            settings: {
                ...settings,
                ufgServerUrl: accountInfo.ufgServer.ufgServerUrl,
                accessToken: accountInfo.ufgServer.accessToken,
            },
            logger,
        });
        const deviceProviders = {
            getChromeEmulationDevices: ufgClient.getChromeEmulationDevices.bind(ufgClient),
            getIOSDevices: ufgClient.getIOSDevices.bind(ufgClient),
        };
        const environments = settings.environments || [];
        // Validate environments first (same as open() does)
        await (0, verify_environment_info_1.verifyEnvironmentsInfo)({ environments, ufgClient });
        const { scrollLength, waitingTime, maxAmountToScroll } = {
            ...defaults_1.DEFAULT_LAZY_LOAD,
            ...(typeof settings.lazyLoad === 'object' ? settings.lazyLoad : {}),
        };
        // Calculate lazy load time per breakpoint
        const lazyLoadTimePerBreakpoint = settings.lazyLoad ? Math.ceil(maxAmountToScroll / scrollLength) * waitingTime : 0;
        // Calculate total times (only handle number case for time estimation, default from defaults.ts)
        const waitBeforeCapture = Number(settings.waitBeforeCapture) || defaults_1.DEFAULT_WAIT_BEFORE_CAPTURE;
        // Calculate required sizes count using the same logic as take-dom-snapshots
        // Match the early return logic: if no layoutBreakpoints.breakpoints, take single snapshot
        const waitCount = !((_a = settings.layoutBreakpoints) === null || _a === void 0 ? void 0 : _a.breakpoints)
            ? 1
            : await (0, calculate_required_sizes_1.calculateRequiredSizesCount)(environments, settings, deviceProviders);
        // For numberOfBreakpoints, we need to count unique widths regardless of layoutBreakpoints
        // We can reuse the same logic but ignore layoutBreakpoints settings
        const settingsForBreakpointCount = { ...settings, layoutBreakpoints: undefined };
        const numberOfBreakpoints = await (0, calculate_required_sizes_1.calculateRequiredSizesCount)(environments, settingsForBreakpointCount, deviceProviders);
        const waitBeforeCaptureTime = waitBeforeCapture * waitCount;
        const lazyLoadTime = lazyLoadTimePerBreakpoint * numberOfBreakpoints;
        return {
            totalTime: waitBeforeCaptureTime + lazyLoadTime,
            breakdown: {
                lazyLoadTimePerBreakpoint,
                numberOfBreakpoints,
                waitBeforeCaptureTime,
            },
        };
    };
}
exports.makeCalculateEstimatedTime = makeCalculateEstimatedTime;
