/// <reference types="node" />
import type { ExecOptions } from 'child_process';
import { type Logger } from '@applitools/logger';
type Options = {
    execOptions?: ExecOptions;
    logger: Logger;
    ignoreGitBranching?: boolean;
};
type ExtractGitBranchingTimestampOptions = {
    branchName: string;
    execOptions?: ExecOptions;
    logger?: Logger;
    parentBranchName: string;
};
type ExtractCurrentCommitTimestampOptions = {
    execOptions?: ExecOptions;
    logger?: Logger;
};
export declare const cacheKey = "default";
/**
 * Get the primary remote name (cached for performance)
 * Prefers 'origin' if it exists, otherwise uses the first available remote
 */
export declare const getPrimaryRemoteName: (({ execOptions, logger }: {
    execOptions?: ExecOptions | undefined;
    logger?: Logger | undefined;
}) => Promise<string>) & {
    getCachedValues(): Promise<string>[];
    setCachedValue(key: any, value: Promise<string>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export declare const extractLatestCommitInfo: (({ execOptions, logger, }: ExtractCurrentCommitTimestampOptions) => Promise<{
    timestamp: string;
    sha: string;
} | undefined>) & {
    getCachedValues(): Promise<{
        timestamp: string;
        sha: string;
    } | undefined>[];
    setCachedValue(key: any, value: Promise<{
        timestamp: string;
        sha: string;
    } | undefined>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export declare const extractGitBranch: (({ execOptions, logger }: Options) => Promise<string | undefined>) & {
    getCachedValues(): Promise<string | undefined>[];
    setCachedValue(key: any, value: Promise<string | undefined>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export declare const extractGitRepo: (({ execOptions, logger }: Options) => Promise<{
    name?: string;
    owner?: string;
}>) & {
    getCachedValues(): Promise<{
        name?: string | undefined;
        owner?: string | undefined;
    }>[];
    setCachedValue(key: any, value: Promise<{
        name?: string | undefined;
        owner?: string | undefined;
    }>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export declare function extractBuildIdFromCI(): Promise<string | undefined>;
export declare const extractBranchingTimestamp: (({ branchName, parentBranchName, execOptions, logger, }: ExtractGitBranchingTimestampOptions) => Promise<string | undefined>) & {
    getCachedValues(): Promise<string | undefined>[];
    setCachedValue(key: any, value: Promise<string | undefined>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export declare function isISODate(str: string): boolean;
/**
 * Extracts a list of ancestor branches for the given branch, ordered by most recent commit timestamp.
 *
 * Algorithm:
 * 1. Check if shallow clone and should skip (via APPLITOOLS_SKIP_BRANCH_LOOKUP_IN_SHALLOW_CLONE)
 * 2. Ensure remote branches are available (fetch if needed for single-branch/shallow clones)
 * 3. Use git topology to discover ancestor branches efficiently (O(log N) via --first-parent --simplify-by-decoration)
 * 4. For each discovered branch, extract the branching timestamp (latest viable commit where branch existed)
 * 5. Sort results by timestamp descending (most recent first)
 * 6. Return cached results (5-minute TTL) to avoid redundant git operations
 *
 * @param gitBranchName - The branch to analyze
 * @param execOptions - Git execution options (e.g., cwd)
 * @param logger - Logger instance for debugging
 * @returns Array of ancestor branches with timestamps, or undefined if skipped
 */
export declare const extractBranchLookupFallbackList: (({ gitBranchName, execOptions, logger, enableShallowClone, }: {
    gitBranchName: string;
    execOptions?: ExecOptions | undefined;
    logger?: Logger | undefined;
    enableShallowClone: boolean;
}) => Promise<Array<{
    branchName: string;
    latestViableTimestamp: string;
}> | undefined>) & {
    getCachedValues(): Promise<{
        branchName: string;
        latestViableTimestamp: string;
    }[] | undefined>[];
    setCachedValue(key: any, value: Promise<{
        branchName: string;
        latestViableTimestamp: string;
    }[] | undefined>): void;
    clearCache(): void;
    TTL?: number | undefined;
};
export {};
